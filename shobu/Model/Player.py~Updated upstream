from shobu.Model.constants import ROWS, COLS



class Player:


    def __init__(self):


        self.__moves = []
        self.__aggressive_moves = []


def calc_moves(self):
    self.__moves = []
    for i in range(2):
        if self.row > i:
            self.__moves.append([self.row - 1 - i, self.col])
        if self.__row < ROWS - 1 - i:
            self.__moves.append([self.row + 1 + i, self.col])
        if self.col > i:
            self.__moves.append([self.row, self.col - 1 - i])
        if self.col < COLS - 1 - i:
            self.__moves.append([self.row, self.col + 1 + i])
        if self.row > i and self.col > i:
            self.__moves.append([self.row - 1 - i, self.col - 1 - i])
        if self.row < ROWS - 1 - i and self.col > i:
            self.__moves.append([self.row + 1 + i, self.col - 1 - i])
        if self.row > i and self.col < COLS - 1 - i:
            self.__moves.append([self.row - 1 - i, self.col + 1 + i])
        if self.row < ROWS - 1 - i and self.col < COLS - 1 - i:
            self.__moves.append([self.row + 1 + i, self.col + 1 + i])

    for move in list(self.__moves):
        move_row, move_col = move
        cell = self.__board.get_cell(move_row, move_col)
        if cell != 0:
            self.__moves.remove(move)


def calc_aggressive_moves(self):  # incomplete

    self.aggressive_moves = []

    # copy from calc_moves

    for i in range(2):
        if self.row > i:
            self.aggressive_moves.append([self.row - 1 - i, self.col])
        if self.row < ROWS - 1 - i:
            self.aggressive_moves.append([self.row + 1 + i, self.col])
        if self.col > i:
            self.aggressive_moves.append([self.row, self.col - 1 - i])
        if self.col < COLS - 1 - i:
            self.aggressive_moves.append([self.row, self.col + 1 + i])
        if self.row > i and self.col > i:
            self.aggressive_moves.append([self.row - 1 - i, self.col - 1 - i])
        if self.row < ROWS - 1 - i and self.col > i:
            self.aggressive_moves.append([self.row + 1 + i, self.col - 1 - i])
        if self.row > i and self.col < COLS - 1 - i:
            self.aggressive_moves.append([self.row - 1 - i, self.col + 1 + i])
        if self.row < ROWS - 1 - i and self.col < COLS - 1 - i:
            self.aggressive_moves.append([self.row + 1 + i, self.col + 1 + i])

    # end of copy (maybe we should create a function, only for this)

    for move in list(self.moves):
        move_row, move_col = move
        cell = self.board.get_cell(move_row, move_col)
        if cell == 0:
            # removes the moves that end on a 'space' (staying only with moves that remove a stone)
            self.aggressive_moves.remove(move)
